---
id: "momentum-conserved-ed-006"
title: "Entanglement Entropy: Bipartite Measurements"
epic: "momentum-conserved-ed"
status: "pending"
priority: "medium"
dependencies: ["momentum-conserved-ed-001", "momentum-conserved-ed-002", "momentum-conserved-ed-003", "momentum-conserved-ed-004", "momentum-conserved-ed-005"]
estimated_hours: 10
complexity: "medium"
tags: ["entanglement", "entropy", "von-neumann", "renyi", "bipartite"]
---

# Entanglement Entropy: Momentum-space bipartite entanglement calculations

## Overview
Implement minimal bipartite entanglement entropy calculations for momentum eigenstates using only momentum-space operations. Single-file implementation with no real space representations, boundary conditions, or complex data structures for bipartition storage.

## Acceptance Criteria

### Core Functionality
- [ ] Implement von Neumann entropy calculation for momentum-space bipartitions
- [ ] Implement Rényi entropy of order α for α ≥ 0
- [ ] Support momentum-space bipartitions only (no real space)
- [ ] Single function for reduced density matrix construction
- [ ] Direct calculation from momentum eigenstates without storage
- [ ] Support for ground state entanglement only (minimal scope)

### Performance Requirements
- [ ] Compute entanglement entropy for 16-site chain ground state in < 1 minute
- [ ] Memory usage O(2^N_A) where N_A is momentum subsystem size
- [ ] Support momentum-space systems up to 20 momentum modes
- [ ] No caching or parallel computation (minimal approach)
- [ ] Direct calculation without intermediate storage

### Accuracy & Validation
- [ ] Accuracy to machine precision for entropy calculations
- [ ] Validation against known momentum-space results
- [ ] Cross-validation with exact diagonalization for small systems
- [ ] Correct handling of pure states (zero entropy for product states)
- [ ] Proper normalization for reduced density matrices

### Interface Design
- [ ] Single function: `compute_entanglement_entropy(state, momentum_bipartition)`
- [ ] Support von Neumann and Rényi entropy only
- [ ] Direct return of entropy values (no structs)
- [ ] Simple momentum bipartition specification
- [ ] No visualization or export capabilities (minimal scope)

## Technical Details

### Mathematical Framework

#### 1. Momentum-Space Reduced Density Matrix
For a pure momentum eigenstate |ψ⟩ with bipartition in momentum space:
```julia
ρ_A = Tr_B(|ψ⟩⟨ψ|) = Σ_kB (⟨k_B|ψ⟩)(⟨ψ|k_B⟩)
```

#### 2. Entropy Measures
- **Von Neumann Entropy**: S = -Tr(ρ_A log ρ_A)
- **Rényi Entropy**: S_α = (1-α)^(-1) log Tr(ρ_A^α)

#### 3. Momentum Conservation
- **Block Structure**: Reduced density matrices diagonal in momentum sectors
- **Direct Calculation**: Compute entropy without storing ρ_A matrix

### Implementation Architecture

#### 1. Single Function Implementation
```julia
function compute_entanglement_entropy(state::Vector{ComplexF64}, 
                                    momentum_bipartition::Tuple{Vector{Int}, Vector{Int}})
    # 1. Extract momentum subsystem dimensions
    (momentum_A, momentum_B) = momentum_bipartition
    d_A = 2^length(momentum_A)
    
    # 2. Direct entropy calculation from eigenstate
    # No reduced density matrix storage - compute directly
    eigenvals = compute_rdm_eigenvalues(state, momentum_A, momentum_B)
    
    # 3. Compute entropies
    von_neumann = -sum(eigenvals .* log.(eigenvals))
    renyi_2 = -log(sum(eigenvals .^ 2))
    
    return (von_neumann, renyi_2)
end
```

#### 2. Minimal Helper Function
```julia
function compute_rdm_eigenvalues(state::Vector{ComplexF64}, 
                                momentum_A::Vector{Int}, 
                                momentum_B::Vector{Int})
    # Direct eigenvalue computation without matrix construction
    # Exploit momentum conservation for efficiency
    eigenvals = zeros(Float64, 2^length(momentum_A))
    
    # Iterate through momentum basis states
    for (idx_global, coeff) in enumerate(state)
        if abs(coeff) > 1e-15
            # Map to momentum subsystems using bit operations
            contrib = compute_momentum_contribution(idx_global, momentum_A, momentum_B)
            eigenvals .+= abs2(coeff) * contrib
        end
    end
    
    return filter(x -> x > 1e-15, eigenvals)
end
```

### Minimal Features

#### 1. Momentum Bipartition Only
- **Simple Tuple**: (momentum_modes_A, momentum_modes_B)
- **No Boundary Conditions**: Pure momentum space calculations
- **Direct Specification**: User provides momentum mode lists

#### 2. Single Function Interface
- **One Entry Point**: `compute_entanglement_entropy(state, bipartition)`
- **Return Tuple**: (von_neumann_entropy, renyi_2_entropy)
- **No Storage**: Results computed and returned immediately

#### 3. Memory Efficiency
- **No Intermediate Matrices**: Direct eigenvalue computation
- **Minimal Allocations**: Single pass through state vector
- **Bit Operations**: Efficient state manipulation using MBS64 representation

### Performance Optimizations
- **Sparse State Vectors**: Handle sparse eigenstates efficiently
- **Bit Operations**: Direct manipulation of MBS64 integer states
- **Single Pass Algorithm**: Compute entropy in one iteration
- **Minimal Memory**: No intermediate matrix storage

### Validation Strategy
- **Small Systems**: Exact diagonalization validation for 4-8 sites
- **Pure State Checks**: Zero entropy for product states
- **Normalization**: Proper trace condition for reduced density matrices
- **Momentum Conservation**: Verify block-diagonal structure

### Edge Cases & Considerations
- **Numerical Precision**: Handle near-zero eigenvalues
- **Memory Constraints**: Handle momentum subsystems up to 10 modes
- **Single Eigenstate**: Focus on ground state only
- **No Boundary Effects**: Pure momentum space calculations

## Dependencies
- Task 005 (Diagonalization Engine) for eigenstate computation only
- LinearAlgebra.jl for basic matrix operations
- No SparseArrays.jl dependency (minimal approach)

## Testing Strategy
- **Unit Tests**: Test entropy calculation function
- **Validation Tests**: Compare with small system results
- **Minimal Testing**: Focus on correctness over comprehensiveness

## File Structure
- **Single File**: `src/entanglement_entropy.jl` - All implementation in one file
- **No Additional Files**: No separate structs, utilities, or storage modules

---
name: Block Diagonalization Wrapper
status: open
created: 2025-09-05T20:01:57Z
updated: 2025-09-05T20:01:57Z
github: https://github.com/Zou-Bo/MomentumConservedExactDiagonalization.jl/issues/8
depends_on: [001, 002, 003, 004, 4a, 4b]
parallel: true
conflicts_with: []
---

# Task: Block Diagonalization Wrapper - Complete EDPara-to-Eigenvalues Interface

## Description
Create a comprehensive wrapper function that takes an EDPara and momentum block, performs all necessary steps to build the Hamiltonian and diagonalize it using KrylovKit, and outputs the eigen-energies and eigenvectors. This is a simple calling interface that orchestrates the entire diagonalization process.

## Acceptance Criteria
- [ ] Create main wrapper function: `diagonalize_block(edpara::EDPara, block::MomentumBlock)`
- [ ] Generate scattering lists (1-body and 2-body) from EDPara parameters
- [ ] Build sparse Hamiltonian matrix from scattering lists and momentum block
- [ ] Call KrylovKit eigensolvers with appropriate configuration
- [ ] Return eigen-energies and eigenvectors in standardized format
- [ ] Handle both real and complex arithmetic based on Hamiltonian properties
- [ ] Provide options for: number of eigenvalues, which eigenvalues (ground state, excited)
- [ ] Implement proper error handling for convergence failures
- [ ] Add progress monitoring and diagnostic output options
- [ ] Create comprehensive tests with known benchmark systems

## Technical Details

### Main Wrapper Function
```julia
function diagonalize_block(edpara::EDPara, block::MomentumBlock; 
                          nev::Int=1,           # Number of eigenvalues
                          which::Symbol=:SR,     # Which eigenvalues (SR, LR, SI, LI)
                          tol::Real=1e-10,      # Convergence tolerance
                          maxiter::Int=100,     # Maximum iterations
                          verbose::Bool=false)  # Diagnostic output
    
    # Generate scattering lists
    scattering1 = generate_1body_scattering(edpara)
    scattering2 = generate_2body_scattering(edpara)
    
    # Build sparse Hamiltonian
    H = build_sparse_hamiltonian(scattering1, scattering2, block)
    
    # Diagonalize with KrylovKit
    eigen = eigensolve(H, nev, which; tol=tol, maxiter=maxiter)
    
    # Return results
    return eigen.energies, eigen.vectors
end
```

### Integration Flow
1. **Input Validation**: Verify EDPara and block compatibility
2. **Scattering Generation**: Call existing scattering list functions
3. **Matrix Construction**: Build sparse Hamiltonian for the block
4. **Eigensolver Setup**: Configure KrylovKit with appropriate parameters
5. **Diagonalization**: Solve eigenvalue problem
6. **Result Processing**: Format and return eigenvalues/eigenvectors

### KrylovKit Configuration
- **Algorithm**: Automatically select based on problem type
  - Lanczos for Hermitian matrices (ground state, low-lying states)
  - Davidson for interior eigenvalues or degenerate spectra
- **Tolerance**: Machine precision convergence (1e-10 default)
- **Restart Strategy**: Configure for memory-constrained environments
- **Preconditioning**: Optional preconditioning for difficult cases

### Output Format
```julia
struct BlockEigenResults
    energies::Vector{Float64}      # Eigen-energies (sorted)
    vectors::Matrix{ComplexF64}    # Eigenvectors as columns
    momentum::Tuple{Int,Int}       # Block momentum quantum numbers
    block_size::Int                # Dimension of block
    converged::Bool                # Convergence status
    iterations::Int                # Number of iterations
end
```

### Error Handling
- **Convergence Failure**: Return partial results with warning
- **Memory Issues**: Automatic restart with reduced parameters
- **Numerical Issues**: Handle near-degenerate cases properly
- **Invalid Input**: Clear error messages for incompatible inputs

### Performance Optimization
- **Type Stability**: Ensure concrete types throughout pipeline
- **Memory Efficiency**: Minize allocations in hot paths
- **Parallel Ready**: Design for future parallel block processing
- **Benchmarking**: Include performance monitoring hooks

### Files to Create
- `src/diagonalization.jl`: Complete wrapper implementation (single file)
- `test/test_diagonalization.jl`: End-to-end diagonalization tests
- `benchmarks/diagonalization.jl`: Performance benchmarks

### Validation Requirements
- **Correctness**: Compare against known exact diagonalization results
- **Hermiticity**: Verify eigenvectors of Hermitian matrices are orthogonal
- **Convergence**: Check convergence for various system sizes
- **Accuracy**: Validate energy accuracy to machine precision
- **Performance**: Benchmark against original implementation

### Testing Strategy
- **Small Systems**: Compare against dense matrix diagonalization
- **Known Results**: Test against analytical solutions (when available)
- **Benchmark Systems**: Use standard physics models (Heisenberg, Hubbard)
- **Edge Cases**: Test single-state blocks, empty blocks, maximum size

## Dependencies
- [ ] Task 001.md - Package Foundation (provides project structure)
- [ ] Task 002.md - Core EDPara Struct (required for parameters)
- [ ] Task 003.md - MBS64 Type (required for state representation)
- [ ] Task 004.md - Hamiltonian Scattering Lists (required for matrix elements)
- [ ] Task 4a.md - Momentum Block Division (required for block input)
- [ ] Task 4b.md - Sparse Matrix Construction (required for Hamiltonian)
- [ ] KrylovKit.jl dependency (add to Project.toml)

## Effort Estimate
- Size: S (Small)
- Hours: 3 hours
- Parallel: true (simple integration task)

## Definition of Done
- [ ] Main wrapper function implemented with full pipeline
- [ ] KrylovKit integration working correctly
- [ ] Both real and complex arithmetic supported
- [ ] Comprehensive error handling implemented
- [ ] Tests validate correctness against known results
- [ ] Performance benchmarks show acceptable speed
- [ ] Code review confirms clean interface and robust implementation
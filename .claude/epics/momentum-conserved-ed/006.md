---
title: "Entanglement Entropy: Bipartite Measurements"
epic: "momentum-conserved-ed"
task_id: 006
status: "pending"
priority: "medium"
depends_on: [001, 002, 003, 004, 005]
estimated_hours: 10
complexity: "medium"
tags: ["entanglement", "entropy", "von-neumann", "renyi", "bipartite"]
---

# Entanglement Entropy: Implement bipartite entanglement entropy calculations

## Overview
Implement comprehensive entanglement entropy calculations for momentum eigenstates, including von Neumann and Rényi entropies for arbitrary bipartitions, with efficient reduced density matrix construction exploiting translational symmetry.

## Acceptance Criteria

### Core Functionality
- [ ] Implement von Neumann entropy calculation for arbitrary bipartitions
- [ ] Implement Rényi entropy of order α for α ≥ 0
- [ ] Support both contiguous and non-contiguous bipartitions
- [ ] Handle periodic boundary conditions correctly
- [ ] Efficient reduced density matrix construction from eigenstates
- [ ] Support for multiple eigenstates (ground state and excited states)

### Performance Requirements
- [ ] Compute entanglement entropy for 16-site chain ground state in < 1 minute
- [ ] Memory usage O(2^N_A) where N_A is subsystem size (not full 2^N)
- [ ] Support system sizes up to 20 sites for spin-1/2 chains
- [ ] Parallel computation across different bipartitions
- [ ] Efficient caching for repeated calculations

### Accuracy & Validation
- [ ] Accuracy to machine precision for entropy calculations
- [ ] Validation against analytical results for integrable models
- [ ] Cross-validation with exact diagonalization for small systems
- [ ] Correct handling of pure states (zero entropy for product states)
- [ ] Proper normalization and trace conditions for reduced density matrices

### Interface Design
- [ ] Clean API for specifying bipartition schemes
- [ ] Support for multiple entropy measures (von Neumann, Rényi, Tsallis)
- [ ] Efficient state vector operations for reduced density matrices
- [ ] Visualization tools for entanglement patterns
- [ ] Export capabilities for data analysis

## Technical Details

### Mathematical Framework

#### 1. Reduced Density Matrix Construction
For a pure state |ψ⟩ in a bipartite system A⊗B:
```julia
ρ_A = Tr_B(|ψ⟩⟨ψ|) = Σ_i (⟨i_B|ψ⟩)(⟨ψ|i_B⟩)
```

#### 2. Entropy Measures
- **Von Neumann Entropy**: S = -Tr(ρ_A log ρ_A)
- **Rényi Entropy**: S_α = (1-α)^(-1) log Tr(ρ_A^α)
- **Mutual Information**: I(A:B) = S(A) + S(B) - S(A∪B)

#### 3. Momentum Conservation Exploitation
- **Block Structure**: Reduced density matrices respect momentum conservation
- **Translation Symmetry**: Exploit for efficient basis state mapping
- **Parallel Processing**: Independent calculations across momentum sectors

### Implementation Architecture

#### 1. Core Data Structures
```julia
struct Bipartition
    subsystem_A::Vector{Int}    # Site indices in subsystem A
    subsystem_B::Vector{Int}    # Site indices in subsystem B
    boundary_conditions::String # "periodic" or "open"
end

struct EntanglementResult
    von_neumann_entropy::Float64
    renyi_entropies::Dict{Float64, Float64}  # α => S_α
    mutual_information::Float64
    eigenvalues::Vector{Float64}  # Reduced density matrix eigenvalues
end
```

#### 2. Reduced Density Matrix Construction
```julia
function compute_reduced_density_matrix(state::Vector{ComplexF64}, 
                                      bipartition::Bipartition,
                                      basis_mapping::Dict{Int, Vector{Int}})
    # 1. Extract subsystem dimensions
    d_A = 2^length(bipartition.subsystem_A)
    d_B = 2^length(bipartition.subsystem_B)
    
    # 2. Construct mapping from global to local basis
    basis_A, basis_B = construct_subsystem_bases(bipartition)
    
    # 3. Build reduced density matrix
    ρ_A = zeros(ComplexF64, d_A, d_A)
    
    for (idx_global, coeff) in enumerate(state)
        # Map global state to subsystem states
        (state_A, state_B) = decompose_state(idx_global, bipartition)
        
        # Update reduced density matrix
        for (idx_B, coeff_B) in enumerate(state_B)
            ρ_A .+= coeff * conj(coeff_B) * outer_product(state_A, state_A)
        end
    end
    
    return ρ_A
end
```

#### 3. Entropy Calculation Pipeline
```julia
function compute_entanglement_entropy(state::Vector{ComplexF64}, 
                                    bipartition::Bipartition)
    # 1. Construct reduced density matrix
    ρ_A = compute_reduced_density_matrix(state, bipartition)
    
    # 2. Diagonalize reduced density matrix
    eigenvals = eigvals(ρ_A)
    eigenvals = filter(x -> x > 1e-15, eigenvals)  # Remove numerical noise
    
    # 3. Compute entropies
    von_neumann = -sum(eigenvals .* log.(eigenvals))
    renyi_2 = -log(sum(eigenvals .^ 2))
    
    return EntanglementResult(von_neumann, Dict(2.0 => renyi_2), 0.0, eigenvals)
end
```

### Advanced Features

#### 1. Bipartition Schemes
- **Contiguous Bipartitions**: A = {1,2,...,L_A}, B = {L_A+1,...,L}
- **Periodic Bipartitions**: Handle periodic boundary conditions
- **Custom Partitions**: User-defined subsystem divisions
- **All Bipartitions**: Generate all possible contiguous cuts

#### 2. Efficient State Operations
- **Basis State Mapping**: Fast conversion between global and local bases
- **Memory Optimization**: Only store active basis states
- **Parallel Processing**: Multiple bipartitions simultaneously
- **Caching**: Cache reduced density matrices for repeated calculations

#### 3. Symmetry Exploitation
- **Translation Invariance**: Reduce computational complexity
- **Momentum Conservation**: Block-diagonal reduced density matrices
- **Spin Conservation**: Exploit SU(2) symmetry when applicable

### Performance Optimizations
- **Sparse State Vectors**: Handle sparse eigenstates efficiently
- **Symmetry Reduction**: Exploit translational and spin symmetries
- **Parallel Processing**: Multi-thread across bipartitions
- **Memory Pooling**: Reuse memory for temporary arrays

### Validation Strategy
- **Analytical Results**: Compare with integrable model predictions
- **Small Systems**: Exact diagonalization validation
- **Symmetry Checks**: Verify proper handling of symmetries
- **Edge Cases**: Single-site, empty, and full subsystems

### Edge Cases & Considerations
- **Numerical Precision**: Handle near-zero eigenvalues
- **Degenerate States**: Proper entropy calculation for degenerate eigenvalues
- **Memory Constraints**: Handle large subsystem sizes gracefully
- **Boundary Effects**: Correct treatment of open vs. periodic boundaries

## Dependencies
- Task 004 (Hamiltonian Builder) for eigenstate construction
- Task 005 (Diagonalization Engine) for eigenstate computation
- LinearAlgebra.jl for matrix operations and diagonalization
- SparseArrays.jl for efficient state vector operations

## Testing Strategy
- **Unit Tests**: Test individual entropy calculations
- **Integration Tests**: Full entanglement calculation pipeline
- **Validation Tests**: Compare with known analytical results
- **Performance Tests**: Benchmark against system size scaling

## Files to Create/Modify
- `src/entanglement/entropy.jl` - Main entropy calculation routines
- `src/entanglement/reduced_rho.jl` - Reduced density matrix construction
- `src/entanglement/bipartitions.jl` - Bipartition handling
- `test/entanglement/test_entropy.jl` - Comprehensive test suite
- `benchmarks/entanglement_performance.jl` - Performance benchmarks
- `examples/entanglement_analysis.jl` - Usage examples and tutorials
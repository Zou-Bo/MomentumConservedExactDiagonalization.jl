---
id: "momentum-conserved-ed-003"
title: "Hilbert Space Construction: Build momentum-resolved basis construction utilities"
epic: "momentum-conserved-ed"
status: "pending"
priority: "high"
parallel: true
estimate: "6 hours"
dependencies: ["momentum-conserved-ed-001", "momentum-conserved-ed-002"]
created: "2025-09-05"
assignee: ""
tags: ["core", "hilbert-space", "basis-construction", "momentum-conservation"]
---

# Task: Hilbert Space Construction

## Objective
Implement the core utilities for constructing momentum-resolved Hilbert spaces for exact diagonalization. This includes basis state generation, momentum projection, and efficient indexing schemes for sparse matrix operations.

## Acceptance Criteria
- [ ] Implement `BasisState` struct to represent individual basis states
- [ ] Create `MomentumBasis` struct to manage the full momentum-resolved basis
- [ ] Implement efficient bit representation for basis states (64-bit integers)
- [ ] Build momentum projection using discrete Fourier transform
- [ ] Add basis state indexing and lookup systems
- [ ] Implement basis size calculation and memory estimation
- [ ] Create validation utilities for basis consistency
- [ ] Add comprehensive tests with small system examples
- [ ] Implement basis state iteration interface
- [ ] Add basis reduction techniques for sparse representations

## Technical Details

### Basis State Representation
```julia
struct BasisState
    state::UInt64    # Bit representation of occupation
    phase::Float64   # Phase factor from momentum projection
    weight::Float64  # Normalization weight
end

# Bit manipulation utilities
@inline function get_occupation(state::UInt64, site::Int)
    (state >> (site - 1)) & 0x1
end

@inline function set_occupation(state::UInt64, site::Int, occ::Bool)
    occ ? (state | (0x1 << (site - 1))) : (state & ~(0x1 << (site - 1)))
end

@inline function count_particles(state::UInt64)
    count_ones(state)
end
```

### Momentum Basis Structure
```julia
struct MomentumBasis{T<:Real}
    para::EDPara{T}          # System parameters
    k::Int                   # Momentum sector
    N::Int                   # Particle number
    basis_states::Vector{UInt64}  # All basis states in this sector
    state_indices::Dict{UInt64,Int}  # State -> index mapping
    total_dimension::Int     # Total dimension of the basis
    
    function MomentumBasis(para::EDPara{T}) where T<:Real
        # Validate parameters
        @assert para.spinless "Only spinless fermions supported currently"
        
        # Generate all basis states for given k and N
        basis_states = generate_momentum_basis(para.L, para.N, para.k)
        
        # Create index mapping
        state_indices = Dict(s => i for (i, s) in enumerate(basis_states))
        
        new{T}(para, para.k, para.N, basis_states, state_indices, length(basis_states))
    end
end
```

### Momentum Projection Algorithm
```julia
function generate_momentum_basis(L::Int, N::Int, k::Int)
    basis_states = UInt64[]
    
    # Generate all real space basis states with N particles
    all_states = generate_real_space_basis(L, N)
    
    # Apply momentum projection
    for state in all_states
        momentum_phase = calculate_momentum_phase(state, k, L)
        if abs(momentum_phase) > 1e-12  # Non-zero projection
            push!(basis_states, state)
        end
    end
    
    return sort(basis_states)  # Consistent ordering
end

function calculate_momentum_phase(state::UInt64, k::Int, L::Int)
    phase = 0.0 + 0.0im
    
    # Generate all translations of the state
    for shift in 0:L-1
        translated = translate_state(state, shift, L)
        phase_contribution = exp(2ฯ * im * k * shift / L)
        phase += phase_contribution
    end
    
    return abs(phase) / L  # Normalized projection amplitude
end

@inline function translate_state(state::UInt64, shift::Int, L::Int)
    shifted = zero(UInt64)
    for site in 1:L
        new_site = mod1(site + shift, L)
        if get_occupation(state, site)
            shifted = set_occupation(shifted, new_site, true)
        end
    end
    return shifted
end
```

### Real Space Basis Generation
```julia
function generate_real_space_basis(L::Int, N::Int)
    states = UInt64[]
    
    # Generate all N-particle states using bit manipulation
    function generate_recursive(current_state::UInt64, current_site::Int, particles_left::Int)
        if particles_left == 0
            push!(states, current_state)
            return
        end
        
        if L - current_site + 1 < particles_left
            return  # Not enough sites left
        end
        
        # Place particle at current site
        new_state = set_occupation(current_state, current_site, true)
        generate_recursive(new_state, current_site + 1, particles_left - 1)
        
        # Skip current site
        generate_recursive(current_state, current_site + 1, particles_left)
    end
    
    generate_recursive(zero(UInt64), 1, N)
    return states
end
```

### Basis Utilities
```julia
# State lookup and indexing
function get_state_index(basis::MomentumBasis, state::UInt64)
    get(basis.state_indices, state, nothing)
end

function get_state_by_index(basis::MomentumBasis, index::Int)
    1 <= index <= basis.total_dimension || error("Index out of bounds")
    basis.basis_states[index]
end

# Basis information
function basis_size(para::EDPara)
    # Calculate without generating all states
    L, N, k = para.L, para.N, para.k
    # Use combinatorial formulas for estimation
    real_space_size = binomial(L, N)
    # Momentum sectors reduce this by approximately L
    estimated_size = real_space_size รท L
    return estimated_size
end

function memory_estimate(para::EDPara)
    basis_dim = basis_size(para)
    # Estimate memory for basis states and indices
    sizeof(UInt64) * basis_dim +  # basis_states
    sizeof(Int) * basis_dim +     # state_indices overhead
    1024  # Additional overhead
end
```

### Iteration Interface
```julia
# Make MomentumBasis iterable
Base.iterate(basis::MomentumBasis) = iterate(basis.basis_states)
Base.iterate(basis::MomentumBasis, state) = iterate(basis.basis_states, state)
Base.length(basis::MomentumBasis) = basis.total_dimension
Base.eltype(::Type{MomentumBasis{T}}) where T = UInt64

# Iterator for basis states with phases
struct MomentumBasisIterator
    basis::MomentumBasis
end

Base.iterate(iter::MomentumBasisIterator) = 
    iterate(zip(iter.basis.basis_states, 1:length(iter.basis)))
```

## Test Requirements
- Small system exact diagonalization (L=4, N=2) with known results
- Bit manipulation correctness tests
- Momentum projection tests with translational symmetry
- Basis size calculations vs actual generation
- Memory usage benchmarks
- State indexing round-trip tests
- Iteration interface tests
- Edge cases (N=0, N=L, k=0, k=L-1)

## Performance Considerations
- Use 64-bit integers for systems up to L=64
- Pre-compute translation tables for common system sizes
- Use bit manipulation for efficient state operations
- Cache basis states for repeated calculations
- Implement lazy evaluation for large systems

## Implementation Steps
1. Implement basic bit manipulation utilities
2. Create BasisState and MomentumBasis structs
3. Implement real space basis generation
4. Add momentum projection algorithm
5. Create state indexing system
6. Add basis utilities and information methods
7. Implement iteration interface
8. Write comprehensive tests
9. Add performance benchmarks
10. Create documentation with examples

## Definition of Done
- Momentum basis construction works for L<=16 systems
- All tests pass with correct physics results
- Memory usage is within acceptable bounds
- Performance benchmarks show sub-second basis generation for L=12
- Documentation includes usage examples
- Basis states can be efficiently indexed and retrieved
- Code is type-stable and passes Julia static analysis
---
id: "momentum-conserved-ed-002"
title: "Core EDPara Struct: Design and implement EDPara parameter container with validation"
epic: "momentum-conserved-ed"
status: "pending"
priority: "high"
parallel: true
estimate: "4 hours"
dependencies: ["momentum-conserved-ed-001"]
created: "2025-09-05"
assignee: ""
tags: ["core", "data-structures", "validation"]
---

# Task: Core EDPara Struct Implementation

## Objective
Design and implement the `EDPara` struct that serves as the central parameter container for exact diagonalization calculations with momentum conservation. This struct must be type-stable, validate inputs, and provide a clean interface for specifying system parameters.

## Acceptance Criteria
- [ ] Design `EDPara` struct with all necessary fields for ED calculations
- [ ] Implement comprehensive input validation for all parameters
- [ ] Add constructor methods with multiple dispatch for different parameter combinations
- [ ] Include detailed docstrings with mathematical definitions
- [ ] Create comprehensive tests covering edge cases and validation
- [ ] Implement `show` and `display` methods for debugging
- [ ] Add serialization support (save/load parameters)
- [ ] Include parameter bounds checking and physical consistency validation

## Technical Details

### EDPara Struct Design
```julia
struct EDPara{T<:Real}
    # System size parameters
    L::Int          # System size (number of sites)
    N::Int          # Number of particles
    k::Int          # Momentum quantum number (0 <= k < L)
    
    # Hamiltonian parameters
    t::T            # Hopping amplitude
    U::T            # On-site interaction
    V::T            # Nearest-neighbor interaction
    μ::T            # Chemical potential
    
    # Basis parameters
    pbc::Bool       # Periodic boundary conditions
    spinless::Bool  # Spinless fermions vs spinful
    conserved_sz::Bool  # Whether Sz is conserved (for spinful)
    
    # Numerical parameters
    tol::T          # Numerical tolerance
    max_iter::Int   # Maximum iterations for iterative solvers
    
    # Validation constructor
    function EDPara(L::Int, N::Int, k::Int, t::T, U::T, V::T, μ::T;
                   pbc::Bool=true, spinless::Bool=true, conserved_sz::Bool=false,
                   tol::T=1e-12, max_iter::Int=1000) where T<:Real
        # Comprehensive validation
        @assert L > 0 "System size L must be positive"
        @assert N >= 0 "Number of particles N must be non-negative"
        @assert N <= L "Number of particles N cannot exceed system size"
        @assert 0 <= k < L "Momentum k must be in [0, L-1]"
        @assert tol > 0 "Tolerance must be positive"
        @assert max_iter > 0 "Max iterations must be positive"
        
        # Physical consistency checks
        if spinless && conserved_sz
            @warn "conserved_sz=true has no effect for spinless fermions"
        end
        
        new{T}(L, N, k, t, U, V, μ, pbc, spinless, conserved_sz, tol, max_iter)
    end
end
```

### Additional Constructors
```julia
# Convenience constructors for common parameter sets
EDPara(L::Int, N::Int, k::Int; t=1.0, U=0.0, V=0.0, μ=0.0, kwargs...) = 
    EDPara(L, N, k, t, U, V, μ; kwargs...)

# Constructor from Dict/named tuple for parameter sweeps
EDPara(params::Dict{String,Any}) = EDPara(;params...)
```

### Validation Methods
```julia
function validate_parameters(para::EDPara)
    checks = [
        :system_size => para.L > 0,
        :particle_number => 0 <= para.N <= para.L,
        :momentum => 0 <= para.k < para.L,
        :hopping => para.t isa Real,
        :interaction => para.U isa Real,
        :nn_interaction => para.V isa Real,
        :chemical_potential => para.μ isa Real
    ]
    
    failed = [k for (k, v) in checks if !v]
    isempty(failed) || error("Parameter validation failed: $(join(failed, ", "))")
    return true
end
```

### Display and Serialization
```julia
Base.show(io::IO, para::EDPara) = print(io, "EDPara(L=$(para.L), N=$(para.N), k=$(para.k))")
Base.show(io::IO, ::MIME"text/plain", para::EDPara) = _display_parameters(io, para)

# JSON serialization support
using JSON
function Base.convert(::Type{Dict}, para::EDPara)
    Dict(
        "L" => para.L,
        "N" => para.N,
        "k" => para.k,
        "t" => para.t,
        "U" => para.U,
        "V" => para.V,
        "μ" => para.μ,
        "pbc" => para.pbc,
        "spinless" => para.spinless,
        "conserved_sz" => para.conserved_sz,
        "tol" => para.tol,
        "max_iter" => para.max_iter
    )
end
```

## Test Requirements
- Parameter validation tests (all edge cases)
- Constructor tests with different parameter combinations
- Physical consistency tests
- Serialization round-trip tests
- Display method tests
- Type stability tests

## Implementation Steps
1. Define the EDPara struct with type parameters
2. Implement primary constructor with full validation
3. Add convenience constructors
4. Implement show/display methods
5. Add serialization support
6. Write comprehensive tests
7. Add documentation with usage examples

## Definition of Done
- EDPara struct is fully implemented and tested
- All validation passes for typical use cases
- Tests cover >95% of code paths
- Documentation is complete with examples
- Struct can be serialized and deserialized without data loss
- Performance benchmarks show type stability